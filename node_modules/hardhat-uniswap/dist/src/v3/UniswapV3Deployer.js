"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniswapV3Deployer = void 0;
const ethers_1 = require("ethers");
const deployFactory_1 = __importDefault(require("./deployers/deployFactory"));
const deployRouter_1 = __importDefault(require("./deployers/deployRouter"));
const deployWETH9_1 = __importDefault(require("./deployers/deployWETH9"));
const Interface_1 = __importDefault(require("./Interface"));
const common_1 = require("../common");
const deployTokenDescriptor_1 = __importDefault(require("./deployers/deployTokenDescriptor"));
const deployPositionManager_1 = __importDefault(require("./deployers/deployPositionManager"));
const deployNFTDescriptorLibrary_1 = __importDefault(require("./deployers/deployNFTDescriptorLibrary"));
//const utils_1 = require("ethers/lib/utils");
const UniswapV3Pool_json_1 = require("@uniswap/v3-core/artifacts/contracts/UniswapV3Pool.sol/UniswapV3Pool.json");
const tokenUtil_1 = require("../util/tokenUtil");
class UniswapV3Deployer {
    constructor(hre, _signer) {
        this.MIN_TICK = 0;
        this.MAX_TICK = 100000;
        this.MAX_UINT128 = BigInt("340282366920938463463374607431768211455");
        this.Interface = Interface_1.default;
        this.hre = hre;
        this._signer = _signer;
        this._tokens = new Map();
    }
    async deploy(signer = this._signer) {
        const { factory, Factory } = await (0, deployFactory_1.default)(signer);
        const { weth9, WETH9 } = await (0, deployWETH9_1.default)(signer);
        const { router, Router } = await (0, deployRouter_1.default)(signer, factory, weth9);
        const { nftDescriptorLibrary, NFTDescriptorLibrary } = await (0, deployNFTDescriptorLibrary_1.default)(signer);
        const { tokenDescriptor, TokenDescriptor } = await (0, deployTokenDescriptor_1.default)(signer, nftDescriptorLibrary, weth9);
        const { positionManager, PositionManager } = await (0, deployPositionManager_1.default)(signer, factory, weth9, tokenDescriptor);
        this._factory = factory;
        this._router = router;
        this._weth = weth9;
        this._tokenDescriptor = tokenDescriptor;
        this._positionManager = positionManager;
        this._nftDescriptorLibrary = nftDescriptorLibrary;
        return {
            weth9,
            WETH9,
            factory,
            Factory,
            router,
            Router,
            tokenDescriptor,
            TokenDescriptor,
            nftDescriptorLibrary,
            NFTDescriptorLibrary,
            positionManager,
            PositionManager
        };
    }
    async getWeth(signer = this._signer) {
        if (!this._weth) {
            const { weth9 } = await (0, deployWETH9_1.default)(signer);
            this._weth = weth9;
        }
        return this._weth;
    }
    async getFactory(signer = this._signer) {
        if (!this._factory) {
            const { factory } = await (0, deployFactory_1.default)(signer);
            this._factory = factory;
        }
        return this._factory;
    }
    async getRouter(signer = this._signer) {
        if (!this._router) {
            const { router } = await (0, deployRouter_1.default)(signer, await this.getFactory(signer), await this.getWeth(signer));
            this._router = router;
        }
        return this._router;
    }
    async getTokenDescriptor(signer = this._signer) {
        if (!this._tokenDescriptor) {
            const { tokenDescriptor } = await (0, deployTokenDescriptor_1.default)(signer, await this.getNftDescriptorLibrary(signer), await this.getWeth(signer));
            this._tokenDescriptor = tokenDescriptor;
        }
        return this._tokenDescriptor;
    }
    async getPositionManager(signer = this._signer) {
        if (!this._positionManager) {
            const { positionManager } = await (0, deployPositionManager_1.default)(signer, await this.getFactory(signer), await this.getWeth(signer), await this.getTokenDescriptor(signer));
            this._positionManager = positionManager;
        }
        return this._positionManager;
    }
    async getNftDescriptorLibrary(signer = this._signer) {
        if (!this._nftDescriptorLibrary) {
            const { nftDescriptorLibrary } = await (0, deployNFTDescriptorLibrary_1.default)(signer);
            this._nftDescriptorLibrary = nftDescriptorLibrary;
        }
        return this._nftDescriptorLibrary;
    }
    async createERC20(name, symbol, signer = this._signer) {
        const { erc20 } = await common_1.CommonDeployers.deployERC20(signer, name, symbol, await this.getRouter(signer));
        this._tokens.set(erc20.target, erc20);
        return erc20;
    }
    getERC20(address) {
        return this._tokens.get(address);
    }
    /**
    * @param {ExactInputSingleOptions} options
    * @member {SignerWithAddress} signer
    * @member {string} tokenIn
    * @member {string} tokenOut
    * @member {number} fee
    * @member {number | BigNumber} amountIn
    */
    async exactInputSingle(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let amountInEther = options.amountIn;
        if (typeof options.amountIn == "number") {
            amountInEther = (0, ethers_1.parseEther)(options.amountIn.toString());
        }
        const exactInputSingleParams = {
            tokenIn: options.tokenIn,
            tokenOut: options.tokenOut,
            fee: options.fee,
            recipient: (await options.signer.target),
            deadline: Math.floor(Date.now() / 1000) + 1000,
            amountIn: amountInEther,
            amountOutMinimum: 0,
            sqrtPriceLimitX96: 0
        };
        await router.connect(options.signer).exactInputSingle(exactInputSingleParams);
    }
    /**
    * @param {ExactInputOptions} options
    * @member {SignerWithAddress} signer
    * @member {Array<string | number>} path
    * @member {number | BigNumber} amountin
    */
    async exactInput(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let amountInEther = options.amountIn;
        if (typeof options.amountIn == "number") {
            amountInEther = (0, ethers_1.parseEther)(options.amountIn.toString());
        }
        let types = Array(options.path.length).fill("address");
        for (let i = 0; i < options.path.length; i++) {
            if (i % 2 != 0) {
                types[i] = "uint24";
            }
        }
        //@ts-ignore
        const path = this.hre.ethers.utils.solidityPack(types, options.path);
        const exactInputParams = {
            path: path,
            recipient: await options.signer.address,
            deadline: Math.floor(Date.now() / 1000) + 1000,
            amountIn: amountInEther,
            amountOutMinimum: 0
        };
        await router.connect(options.signer).exactInput(exactInputParams);
    }
    /**
    * @param {ExactOutputSingleOptions} options
    * @member {SignerWithAddress} signer
    * @member {string} tokenIn
    * @member {string} tokenOut
    * @member {number} fee
    * @member {number | BigNumber} amountOut
    */
    async exactOutputSingle(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let amountOutEther = options.amountOut;
        if (typeof options.amountOut == "number") {
            amountOutEther = (0, ethers_1.parseEther)(options.amountOut.toString());
        }
        const exactOutputSingleParams = {
            tokenIn: options.tokenIn,
            tokenOut: options.tokenOut,
            fee: options.fee,
            recipient: (await options.signer.address),
            deadline: Math.floor(Date.now() / 1000) + 1000,
            amountOut: amountOutEther.toString(),
            //@ts-ignore
            amountInMaximum: (0, ethers_1.parseEther)("1000000000"),
            sqrtPriceLimitX96: 0
        };
        await router.connect(options.signer).exactOutputSingle(exactOutputSingleParams);
    }
    /**
    * @param {ExactOutputOptions} options
    * @member {SignerWithAddress} signer
    * @member {Array<string | number>} path
    * @member {number | BigNumber} amountOut
    */
    async exactOutput(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let amountOutEther = options.amountOut;
        if (typeof options.amountOut == "number") {
            amountOutEther = (0, ethers_1.parseEther)(options.amountOut.toString());
        }
        let types = Array(options.path.length).fill("address");
        for (let i = 0; i < options.path.length; i++) {
            if (i % 2 != 0) {
                types[i] = "uint24";
            }
        }
        //@ts-ignore
        const path = this.hre.ethers.utils.solidityPack(types, options.path);
        const exactOutputParams = {
            path: path,
            recipient: await options.signer.address,
            deadline: Math.floor(Date.now() / 1000) + 1000,
            amountOut: amountOutEther,
            //@ts-ignore
            amountInMaximum: this.hre.ethers.constants.MaxInt256
        };
        await router.connect(options.signer).exactOutput(exactOutputParams);
    }
    /**
    * @param {MintOptions} options
    * @member {SignerWithAddress} signer
    * @member {string} token0
    * @member {string} token1
    * @member {number} fee
    * @member {number | BigNumber} amount0Desired
    * @member {number | BigNumber} amount1Desired
    * @member {number} price
    */
    async mintPosition(options) {
        options.signer ?? (options.signer = this._signer);
        const positionManager = await this.getPositionManager(options.signer);
        const signerAddress = await options.signer.address;
        //Parse amounts into ether
        let amount0DesiredEther = options.amount0Desired;
        let amount1DesiredEther = options.amount1Desired;
        if (typeof options.amount0Desired == "number") {
            amount0DesiredEther = (0, ethers_1.parseEther)(options.amount0Desired.toString());
        }
        if (typeof options.amount1Desired == "number") {
            amount1DesiredEther = (0, ethers_1.parseEther)(options.amount1Desired.toString());
        }
        // Approve Tokens
        //@ts-ignore
        await (this._tokens.get(options.token0)).connect(options.signer).approve(positionManager.target, this.hre.ethers.constants.MaxInt256);
        //@ts-ignore
        await (this._tokens.get(options.token1)).connect(options.signer).approve(positionManager.target, this.hre.ethers.constants.MaxInt256);
        let token0, token1;
        // Sort tokens to avoid revert() from createAndInitializePoolIfNecessary in PoolInitializer
        if (options.token0 < options.token1) {
            token0 = options.token0;
            token1 = options.token1;
        }
        else {
            token0 = options.token1;
            token1 = options.token0;
        }
        // calculate squareRootPrice for desired price
        const sqrtPrice = (0, tokenUtil_1.calculateSqrtPriceX96)(options.price, 18, 18);
        // create and initialize pool if necessary
        await positionManager.connect(options.signer).createAndInitializePoolIfNecessary(token0, token1, 3000, sqrtPrice.toFixed(0));
        const poolAddress = await (await this.getFactory(options.signer)).getPool(token0, token1, 3000);
        const Pool = new ethers_1.ContractFactory(UniswapV3Pool_json_1.abi, UniswapV3Pool_json_1.bytecode);
        const pool = await Pool.attach(poolAddress);
        let slot0 = await pool.connect(options.signer).slot0();
        // get tick spacing info and nearest tick from Pool
        let tickSpacing = parseInt(await pool.connect(options.signer).tickSpacing());
        let nearestTick = (0, tokenUtil_1.getNearestUsableTick)(parseInt(slot0.tick), tickSpacing);
        const mintParams = {
            token0: token0,
            token1: token1,
            fee: options.fee,
            tickLower: nearestTick - tickSpacing * 2,
            tickUpper: nearestTick + tickSpacing * 2,
            amount0Desired: amount0DesiredEther,
            amount1Desired: amount1DesiredEther,
            amount0Min: 0,
            amount1Min: 0,
            recipient: signerAddress,
            deadline: 9678825033
        };
        // Mint with desired amounts
        const res = await positionManager.connect(options.signer).mint(mintParams);
        const tx = await res.wait();
        return Number(tx.logs[tx.logs.length - 1].topics[1]);
    }
    /**
    * @param {CollectOptions} options
    * @member {SignerWithAddress} signer
    * @member {number} tokenId
    */
    async collectFees(options) {
        options.signer ?? (options.signer = this._signer);
        const positionManager = await this.getPositionManager(options.signer);
        const collectParams = {
            tokenId: options.tokenId,
            recipient: await options.signer.address,
            amount0Max: this.MAX_UINT128,
            amount1Max: this.MAX_UINT128
        };
        const res = await positionManager.collect(collectParams);
        const tx = await res.wait();
        const args = tx.events[tx.events.length - 1].args;
        const amount0 = args[2];
        const amount1 = args[3];
        return Number(tx.logs[tx.logs.length - 1].topics[1]);
    }
    /**
    * @param {IncreaseLiquidityOptions} options
    * @member {SignerWithAddress} signer
    * @member {number} tokenId
    * @member {number | BigNumber} amount0Desired
    * @member {number | BigNumber} amount1Desired
    */
    async increaseLiquidity(options) {
        options.signer ?? (options.signer = this._signer);
        const positionManager = await this.getPositionManager(options.signer);
        let amount0DesiredEther = options.amount0Desired;
        let amount1DesiredEther = options.amount1Desired;
        if (typeof options.amount0Desired == "number") {
            amount0DesiredEther = (0, ethers_1.parseEther)(options.amount0Desired.toString());
        }
        if (typeof options.amount1Desired == "number") {
            amount1DesiredEther = (0, ethers_1.parseEther)(options.amount1Desired.toString());
        }
        const increaseLiquidityParams = {
            tokenId: options.tokenId,
            amount0Desired: amount0DesiredEther,
            amount1Desired: amount1DesiredEther,
            amount0Min: 0,
            amount1Min: 0,
            deadline: Math.floor(Date.now() / 1000) + 1000
        };
        await positionManager.connect(options.signer).increaseLiquidity(increaseLiquidityParams);
    }
    /**
    * @param {DecreaseLiquidityOptions} options
    * @member {SignerWithAddress} signer
    * @member {number} tokenId
    * @member {number | BigNumber} liquidityAmount
    */
    async decreaseLiquidity(options) {
        options.signer ?? (options.signer = this._signer);
        const positionManager = await this.getPositionManager(options.signer);
        let liquidityEther = options.amountLiquidity;
        if (typeof options.amountLiquidity == "number") {
            liquidityEther = (0, ethers_1.parseEther)(options.amountLiquidity.toString());
        }
        const decreaseLiquidityParams = {
            tokenId: options.tokenId,
            liquidity: liquidityEther,
            amount0Min: 0,
            amount1Min: 0,
            deadline: Math.floor(Date.now() / 1000) + 1000
        };
        const res = await positionManager.connect(options.signer).decreaseLiquidity(decreaseLiquidityParams);
        const tx = await res.wait();
        const args = tx.events[tx.events.length - 1].args;
        const amount0 = args[2];
        const amount1 = args[3];
        return [amount0, amount1];
    }
}
exports.UniswapV3Deployer = UniswapV3Deployer;
//# sourceMappingURL=UniswapV3Deployer.js.map