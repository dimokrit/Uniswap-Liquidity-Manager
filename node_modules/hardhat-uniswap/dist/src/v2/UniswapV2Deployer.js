"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniswapV2Deployer = void 0;
const ethers_1 = require("ethers");
const deployFactory_1 = __importDefault(require("./deployers/deployFactory"));
const deployRouter_1 = __importDefault(require("./deployers/deployRouter"));
const deployWETH9_1 = __importDefault(require("./deployers/deployWETH9"));
const Interface_1 = __importDefault(require("./interfaces/Interface"));
const common_1 = require("../common");
//const utils_1 = require("ethers/lib/utils");
class UniswapV2Deployer {
    constructor(hre, _signer) {
        this.Interface = Interface_1.default;
        this.hre = hre;
        this._signer = _signer;
        this._tokens = new Map();
    }
    setSigner(_signer) {
        this._signer = _signer;
    }
    async deploy(signer = this._signer) {
        const { factory, Factory } = await (0, deployFactory_1.default)(signer, signer);
        const { weth9, WETH9 } = await (0, deployWETH9_1.default)(signer);
        const { router, Router } = await (0, deployRouter_1.default)(signer, factory, weth9);
        this._factory = factory;
        this._router = router;
        this._weth = weth9;
        return {
            weth9,
            WETH9,
            factory,
            Factory,
            router,
            Router,
        };
    }
    /**
     * @param signer
     * @returns the WETH contract
     */
    async getWeth(signer = this._signer) {
        if (!this._weth) {
            const { weth9 } = await (0, deployWETH9_1.default)(signer);
            this._weth = weth9;
        }
        return this._weth;
    }
    /**
     * @remarks if the UniswapV2Factory hasn't been created yet, it will create it and return it to you
     * @param signer
     * @returns UniswapV2Factory
     */
    async getFactory(signer = this._signer) {
        if (!this._factory) {
            const { factory } = await (0, deployFactory_1.default)(signer, signer);
            this._factory = factory;
        }
        return this._factory;
    }
    /**
     * @remarks if the UniswapV2Router02 hasn't been created yet, it will create it and return it to you
     * @param signer
     * @returns UniswapV2Router02
     */
    async getRouter(signer = this._signer) {
        if (!this._router) {
            const { router } = await (0, deployRouter_1.default)(signer, await this.getFactory(signer), await this.getWeth(signer));
            this._router = router;
        }
        return this._router;
    }
    /**
     * @param signer
     * @param tokenA address
     * @param tokenB address
     * @returns LP token for tokenA and tokenB
     */
    async getPair(tokenA, tokenB, signer = this._signer) {
        const factory = await this.getFactory(signer);
        const pairAddress = await factory.getPair(tokenA, tokenB);
        //@ts-ignore
        const pair = await this.hre.ethers.getContractAt(require("@uniswap/v2-core/build/UniswapV2Pair.json")
            .abi, pairAddress);
        return pair;
    }
    /**
     * @remarks deploys and saves the token to UniswapV2Deployer._tokens
     * @param signer
     * @param name
     * @param symbol
     * @returns deployed ERC20 contract
     */
    async createERC20(name, symbol, signer = this._signer) {
        const { erc20 } = await common_1.CommonDeployers.deployERC20(signer, name, symbol, await this.getRouter(signer));
        this._tokens.set(erc20.address, erc20);
        return erc20;
    }
    /**
     * @param address
     * @returns ERC20 for a given address
     */
    getERC20(address) {
        return this._tokens.get(address);
    }
    /**
     * @remarks Use this function to add V2 liquidity for an ERC20 token pair
     * @param {AddLiquidityOptions} options
     * @member {SignerWithAddress} signer
     * @member {string} tokenA
     * @member {string} tokenB
     * @member {number | BigNumber} amountTokenA
     * @member {number | BigNumber} amountTokenB?
     */
    async addLiquidity(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        this.addLiquidity;
        let amountAEther = options.amountTokenA;
        let amountBEther = options.amountTokenB;
        if (typeof options.amountTokenA == "number") {
            amountAEther = (0, ethers_1.parseEther)(options.amountTokenA.toString());
        }
        if (typeof options.amountTokenB == "number") {
            amountBEther = (0, ethers_1.parseEther)(options.amountTokenB.toString());
        }
        await router.connect(options.signer).addLiquidity(options.tokenA, options.tokenB, amountAEther, amountBEther, 1, 1, (await options.signer.address), 9678825033);
    }
    /**
     * @remarks Use this function to add V2 liquidity for an ETH token pair
     * @param {AddLiquidityETHOptions} options
     * @member {SignerWithAddress} signer
     * @member {string} token
     * @member {number | BigNumber} amountToken
     * @member {number | BigNumber} amountETH
     */
    async addLiquidityETH(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let amountTokenEther = options.amountToken;
        let amountETHEther = options.amountETH;
        if (typeof options.amountToken == "number") {
            amountTokenEther = (0, ethers_1.parseEther)(options.amountToken.toString());
        }
        if (typeof options.amountETH == "number") {
            amountETHEther = (0, ethers_1.parseEther)(options.amountETH.toString());
        }
        await router.connect(options.signer).addLiquidityETH(options.token, amountTokenEther, 1, 1, (await options.signer.address), 9678825033, { value: amountETHEther });
    }
    /**
    * @param {RemoveLiquidityOptions} options
    * @member {SignerWithAddress} signer
    * @member {string} tokenA
    * @member {string} tokenB
    * @member {number | BigNumber} amountLiquidity
    */
    async removeLiquidity(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let liquidityEther = options.amountLiquidity;
        if (typeof options.amountLiquidity == "number") {
            liquidityEther = (0, ethers_1.parseEther)(options.amountLiquidity.toString());
        }
        await router.connect(options.signer).removeLiquidity(options.tokenA, options.tokenB, liquidityEther, 1, 1, (await options.signer.address), 9678825033);
    }
    /**
    * @param {RemoveLiquidityETHOptions} options
    * @member {SignerWithAddress} signer
    * @member {string} token
    * @member {number | BigNumber} amountLiquidity
    */
    async removeLiquidityETH(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let liquidityEther = options.amountLiquidity;
        if (typeof options.amountLiquidity == "number") {
            liquidityEther = (0, ethers_1.parseEther)(options.amountLiquidity.toString());
        }
        await router.removeLiquidityETH(options.token, liquidityEther, 1, 1, (await options.signer.address), 9678825033);
    }
    /**
     * @remarks This wraps `swapExactTokensForTokens` -- use this for a general swap
    * @param {SwapExactTokensForTokensOptions} options
    * @member {SignerWithAddress} signer
    * @member {number | BigNumber} amountIn
    * @member {string} inputToken
    * @member {string} outputToken
    */
    async swap(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let amountInEther = options.amountIn;
        if (typeof options.amountIn == "number") {
            amountInEther = (0, ethers_1.parseEther)(options.amountIn.toString());
        }
        const path = [options.inputToken, options.outputToken];
        await router.swapExactTokensForTokens(amountInEther, 1, path, (await options.signer.address), 9678825033);
    }
    /**
     * @remarks Use this to swap if your priority is ensuring the amount of tokens you get out
    * @param {SwapTokensForExactTokensOptions} options
    * @member {SignerWithAddress} signer
    * @member {number | BigNumber} amountOut
    * @member {string} inputToken
    * @member {string} outputToken
    */
    async swapTokensForExactTokens(options) {
        options.signer ?? (options.signer = this._signer);
        let amountOutEther = options.amountOut;
        if (typeof options.amountOut == "number") {
            amountOutEther = (0, ethers_1.parseEther)(options.amountOut.toString());
        }
        const router = await this.getRouter(options.signer);
        const path = [options.inputToken, options.outputToken];
        await router.swapTokensForExactTokens(amountOutEther, ethers_1.constants.MaxInt256, path, (await options.signer.address), 9678825033);
    }
    /**
      * @remarks Get the price of tokenA in terms of tokenB
      * @param {QuoteOptions} options
      * @member {SignerWithAddress} signer
      * @member {string} tokenA
      * @member {string} tokenB
      * @member {number | BigNumber} amountA
    */
    async quote(options) {
        options.signer ?? (options.signer = this._signer);
        const router = await this.getRouter(options.signer);
        let amountAEther = options.amountA;
        if (typeof options.amountA == "number") {
            amountAEther = (0, ethers_1.parseEther)(options.amountA.toString());
        }
        const pair = await this.getPair(options.tokenA, options.tokenB, options.signer);
        let reserveA, reserveB, timestamp;
        // Sort reserves with tokens
        if (options.tokenA == await pair.token0()) {
            [reserveA, reserveB, timestamp] = await pair.getReserves();
        }
        else {
            [reserveB, reserveA, timestamp] = await pair.getReserves();
        }
        const quoteAmount = await router.quote(amountAEther, reserveA, reserveB);
        return quoteAmount;
    }
    /**
     * @remarks Get the value of liquidity in terms of token A.
     * @param {GetLiquidityValueInTermsOfTokenAOptions} options
     * @member {SignerWithAddress} signer
     * @member {string} tokenA
     * @member {string} tokenB
     * @member {number | BigNumber} amountLiquidity -- amount of LP tokens you want to know the value of
    */
    async getLiquidityValueInTermsOfTokenA(options) {
        options.signer ?? (options.signer = this._signer);
        const pair = await this.getPair(options.tokenA, options.tokenB, options.signer);
        let reserveA, reserveB, timestamp;
        if (options.tokenA == await pair.token0()) {
            [reserveA, reserveB, timestamp] = await pair.getReserves();
        }
        else {
            [reserveB, reserveA, timestamp] = await pair.getReserves();
        }
        const tvl = reserveA * 2;
        const singleLp = tvl * Number((0, ethers_1.parseEther)("1")) / (await pair.totalSupply());
        if (typeof options.amountLiquidity == "number") {
            return ethers_1.BigNumber.from((singleLp * options.amountLiquidity).toString());
        }
        else {
            return ethers_1.BigNumber.from((singleLp * Number((0, ethers_1.formatEther)(options.amountLiquidity))).toString());
        }
    }
}
exports.UniswapV2Deployer = UniswapV2Deployer;
//# sourceMappingURL=UniswapV2Deployer.js.map