import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { BigNumber, Contract } from "ethers";
import { SwapExactTokensForTokensOptions, AddLiquidityOptions, RemoveLiquidityOptions, QuoteOptions, SwapTokensForExactTokensOptions, GetLiquidityValueInTermsOfTokenAOptions, RemoveLiquidityETHOptions, AddLiquidityETHOptions } from "../../types";
import { HardhatRuntimeEnvironment } from "hardhat/types";
export declare class UniswapV2Deployer {
    Interface: import("./interfaces/Interface").InterfaceType;
    private _factory?;
    private _router?;
    private _weth?;
    private _tokens;
    private _signer;
    hre?: HardhatRuntimeEnvironment;
    constructor(hre: HardhatRuntimeEnvironment, _signer: SignerWithAddress);
    setSigner(_signer: SignerWithAddress): void;
    deploy(signer?: SignerWithAddress): Promise<{
        weth9: Contract;
        WETH9: import("ethers").ContractFactory;
        factory: Contract;
        Factory: import("ethers").ContractFactory;
        router: Contract;
        Router: import("ethers").ContractFactory;
    }>;
    /**
     * @param signer
     * @returns the WETH contract
     */
    getWeth(signer?: SignerWithAddress): Promise<Contract>;
    /**
     * @remarks if the UniswapV2Factory hasn't been created yet, it will create it and return it to you
     * @param signer
     * @returns UniswapV2Factory
     */
    getFactory(signer?: SignerWithAddress): Promise<Contract>;
    /**
     * @remarks if the UniswapV2Router02 hasn't been created yet, it will create it and return it to you
     * @param signer
     * @returns UniswapV2Router02
     */
    getRouter(signer?: SignerWithAddress): Promise<Contract>;
    /**
     * @param signer
     * @param tokenA address
     * @param tokenB address
     * @returns LP token for tokenA and tokenB
     */
    getPair(tokenA: string, tokenB: string, signer?: SignerWithAddress): Promise<any>;
    /**
     * @remarks deploys and saves the token to UniswapV2Deployer._tokens
     * @param signer
     * @param name
     * @param symbol
     * @returns deployed ERC20 contract
     */
    createERC20(name: string, symbol: string, signer?: SignerWithAddress): Promise<Contract>;
    /**
     * @param address
     * @returns ERC20 for a given address
     */
    getERC20(address: string): Contract | undefined;
    /**
     * @remarks Use this function to add V2 liquidity for an ERC20 token pair
     * @param {AddLiquidityOptions} options
     * @member {SignerWithAddress} signer
     * @member {string} tokenA
     * @member {string} tokenB
     * @member {number | BigNumber} amountTokenA
     * @member {number | BigNumber} amountTokenB?
     */
    addLiquidity(options: AddLiquidityOptions): Promise<void>;
    /**
     * @remarks Use this function to add V2 liquidity for an ETH token pair
     * @param {AddLiquidityETHOptions} options
     * @member {SignerWithAddress} signer
     * @member {string} token
     * @member {number | BigNumber} amountToken
     * @member {number | BigNumber} amountETH
     */
    addLiquidityETH(options: AddLiquidityETHOptions): Promise<void>;
    /**
    * @param {RemoveLiquidityOptions} options
    * @member {SignerWithAddress} signer
    * @member {string} tokenA
    * @member {string} tokenB
    * @member {number | BigNumber} amountLiquidity
    */
    removeLiquidity(options: RemoveLiquidityOptions): Promise<void>;
    /**
    * @param {RemoveLiquidityETHOptions} options
    * @member {SignerWithAddress} signer
    * @member {string} token
    * @member {number | BigNumber} amountLiquidity
    */
    removeLiquidityETH(options: RemoveLiquidityETHOptions): Promise<void>;
    /**
     * @remarks This wraps `swapExactTokensForTokens` -- use this for a general swap
    * @param {SwapExactTokensForTokensOptions} options
    * @member {SignerWithAddress} signer
    * @member {number | BigNumber} amountIn
    * @member {string} inputToken
    * @member {string} outputToken
    */
    swap(options: SwapExactTokensForTokensOptions): Promise<void>;
    /**
     * @remarks Use this to swap if your priority is ensuring the amount of tokens you get out
    * @param {SwapTokensForExactTokensOptions} options
    * @member {SignerWithAddress} signer
    * @member {number | BigNumber} amountOut
    * @member {string} inputToken
    * @member {string} outputToken
    */
    swapTokensForExactTokens(options: SwapTokensForExactTokensOptions): Promise<void>;
    /**
      * @remarks Get the price of tokenA in terms of tokenB
      * @param {QuoteOptions} options
      * @member {SignerWithAddress} signer
      * @member {string} tokenA
      * @member {string} tokenB
      * @member {number | BigNumber} amountA
    */
    quote(options: QuoteOptions): Promise<BigNumber>;
    /**
     * @remarks Get the value of liquidity in terms of token A.
     * @param {GetLiquidityValueInTermsOfTokenAOptions} options
     * @member {SignerWithAddress} signer
     * @member {string} tokenA
     * @member {string} tokenB
     * @member {number | BigNumber} amountLiquidity -- amount of LP tokens you want to know the value of
    */
    getLiquidityValueInTermsOfTokenA(options: GetLiquidityValueInTermsOfTokenAOptions): Promise<BigNumber>;
}
//# sourceMappingURL=UniswapV2Deployer.d.ts.map